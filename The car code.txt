// --- MPU Libraries ---
#include "I2Cdev.h"
#include "MPU6050_6Axis_MotionApps20.h"

// --- RF Libraries ---
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

//#define PRINT_DEBUG  // Uncomment to enable Serial debugging

#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
  #include "Wire.h"
#endif

// --- MPU Variables ---
MPU6050 mpu;
bool dmpReady = false;
uint8_t devStatus;
uint16_t packetSize;
uint8_t fifoBuffer[64];
Quaternion q;
VectorFloat gravity;
float ypr[3];  // [yaw, pitch, roll]

// --- RF Setup ---
const uint64_t pipeOut = 0xF9E8F0F0E1LL;
RF24 radio(8, 9);  // CE, CSN

struct PacketData {
  byte xAxisValue;
  byte yAxisValue;
} data;

void setupRadioTransmitter() {
  if (!radio.begin()) {
    #ifdef PRINT_DEBUG
      Serial.println("nRF24L01 not found!");
    #endif
    while (1); // Halt execution
  }

  radio.setDataRate(RF24_250KBPS);  // Lower speed = better range
  radio.openWritingPipe(pipeOut);
  radio.stopListening();  // Transmit mode

  data.xAxisValue = 127;
  data.yAxisValue = 127;
}

void setupMPU() {
  #if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
    Wire.begin();
    Wire.setClock(400000);  // 400kHz I2C
  #endif

  mpu.initialize();

  if (!mpu.testConnection()) {
    #ifdef PRINT_DEBUG
      Serial.println("MPU6050 connection failed!");
    #endif
    while (1); // Halt
  }

  devStatus = mpu.dmpInitialize();

  if (devStatus == 0) {
    mpu.CalibrateAccel(6);
    mpu.CalibrateGyro(6);
    mpu.setDMPEnabled(true);
    packetSize = mpu.dmpGetFIFOPacketSize();
    dmpReady = true;

    #ifdef PRINT_DEBUG
      Serial.println("MPU6050 DMP ready.");
    #endif
  } else {
    #ifdef PRINT_DEBUG
      Serial.print("DMP Init failed (code ");
      Serial.print(devStatus);
      Serial.println(")");
    #endif
    while (1); // Halt
  }
}

void setup() {
  #ifdef PRINT_DEBUG
    Serial.begin(115200);
    while (!Serial);  // For Leonardo/Micro
    Serial.println("Starting Gesture Controller...");
  #endif

  setupRadioTransmitter();
  setupMPU();
}

void loop() {
  if (!dmpReady) return;

  if (mpu.dmpGetCurrentFIFOPacket(fifoBuffer)) {
    mpu.dmpGetQuaternion(&q, fifoBuffer);
    mpu.dmpGetGravity(&gravity, &q);
    mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);

    // Convert pitch & roll to degrees
    int xAxis = constrain(ypr[2] * 180 / M_PI, -90, 90);  // Roll
    int yAxis = constrain(ypr[1] * 180 / M_PI, -90, 90);  // Pitch

    // Map degrees to 0â€“255
    data.xAxisValue = map(xAxis, -90, 90, 0, 255);
    data.yAxisValue = map(yAxis, -90, 90, 255, 0);  // Inverted Y

    // Send data via RF
    bool success = radio.write(&data, sizeof(PacketData));

    #ifdef PRINT_DEBUG
      Serial.print("Roll: "); Serial.print(xAxis);
      Serial.print(" | Pitch: "); Serial.print(yAxis);
      Serial.print(" | Sent: "); Serial.println(success ? "Yes" : "No");
    #endif

    delay(20); // Prevent flooding the RF module
  }
}